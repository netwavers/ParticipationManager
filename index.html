<!DOCTYPE html>
<html lang="ja" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Participation Manager</title>

    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        dark: {
                            900: '#0a0a0a',
                            800: '#121212',
                            700: '#1e1e1e',
                            600: '#2d2d2d',
                        },
                        glass: {
                            100: 'rgba(255, 255, 255, 0.05)',
                            200: 'rgba(255, 255, 255, 0.1)',
                            300: 'rgba(255, 255, 255, 0.15)',
                        },
                        accent: {
                            DEFAULT: '#3b82f6', // Blue-500
                            hover: '#2563eb',   // Blue-600
                            glow: 'rgba(59, 130, 246, 0.5)'
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'slide-up': 'slideUp 0.4s ease-out',
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(10px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' },
                        }
                    }
                }
            }
        }
    </script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #050505;
            background-image:
                radial-gradient(at 0% 0%, rgba(59, 130, 246, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 100%, rgba(236, 72, 153, 0.15) 0px, transparent 50%);
            background-attachment: fixed;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Glassmorphism Utilities */
        .glass-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .glass-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            transition: all 0.2s;
        }

        .glass-input:focus {
            border-color: #3b82f6;
            background: rgba(0, 0, 0, 0.5);
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* List Transitions */
        .list-move,
        .list-enter-active,
        .list-leave-active {
            transition: all 0.4s ease;
        }

        .list-enter-from,
        .list-leave-to {
            opacity: 0;
            transform: translateX(-20px);
        }

        .list-leave-active {
            position: absolute;
            width: 100%;
            /* Ensure it doesn't break layout during leave */
        }
    </style>
</head>

<body class="text-gray-200 min-h-screen flex flex-col overflow-hidden">
    <div id="app" class="flex flex-col h-screen">

        <!-- Header -->
        <header class="glass-panel border-b border-white/5 z-50 shrink-0">
            <div class="max-w-[1800px] mx-auto px-6 h-16 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div
                        class="w-8 h-8 rounded-lg bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center shadow-lg shadow-blue-500/20">
                        <i class="ph-bold ph-users-three text-white text-lg"></i>
                    </div>
                    <h1 class="text-xl font-bold tracking-tight text-white">Participation<span
                            class="text-blue-400">Manager</span></h1>
                </div>

                <div class="flex items-center gap-4">
                    <div v-if="isConnected"
                        class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-green-500/10 border border-green-500/20 text-green-400 text-xs font-medium animate-fade-in">
                        <span class="relative flex h-2 w-2">
                            <span
                                class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                            <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                        </span>
                        Live Connected
                    </div>
                    <button @click="resetAll"
                        class="p-2 text-gray-400 hover:text-red-400 hover:bg-red-500/10 rounded-lg transition-colors"
                        title="Reset All Data">
                        <i class="ph ph-trash text-xl"></i>
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 overflow-hidden p-4 lg:p-6">
            <div class="max-w-[1800px] mx-auto h-full grid grid-cols-1 lg:grid-cols-12 gap-6">

                <!-- Left Column: Controls & Settings (3 cols) -->
                <div class="lg:col-span-3 flex flex-col gap-6 overflow-y-auto pr-2">

                    <!-- Manual Add Card -->
                    <div class="glass-panel rounded-2xl p-5 animate-slide-up" style="animation-delay: 0.1s;">
                        <h2
                            class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-4 flex items-center gap-2">
                            <i class="ph ph-user-plus text-lg"></i> Manual Entry
                        </h2>
                        <div class="flex gap-2">
                            <input type="text" v-model="newUserName" @keyup.enter="addManualUser"
                                class="glass-input w-full rounded-lg px-4 py-2.5 text-sm"
                                placeholder="Enter player name...">
                            <button @click="addManualUser"
                                class="bg-blue-600 hover:bg-blue-500 text-white px-4 rounded-lg transition-all shadow-lg shadow-blue-600/20 active:scale-95">
                                <i class="ph-bold ph-plus"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Session Controls Card -->
                    <div class="glass-panel rounded-2xl p-5 animate-slide-up" style="animation-delay: 0.2s;">
                        <h2
                            class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-4 flex items-center gap-2">
                            <i class="ph ph-sliders-horizontal text-lg"></i> Session Controls
                        </h2>

                        <div class="space-y-4">
                            <div
                                class="flex items-center justify-between bg-white/5 p-3 rounded-xl border border-white/5">
                                <span class="text-sm text-gray-300">Session Size</span>
                                <div class="flex items-center gap-3">
                                    <button @click="sessionSize = Math.max(1, sessionSize - 1)"
                                        class="w-8 h-8 rounded-lg bg-white/5 hover:bg-white/10 flex items-center justify-center transition-colors">
                                        <i class="ph-bold ph-minus text-xs"></i>
                                    </button>
                                    <span class="font-mono font-bold text-lg w-6 text-center">{{ sessionSize }}</span>
                                    <button @click="sessionSize = Math.min(100, sessionSize + 1)"
                                        class="w-8 h-8 rounded-lg bg-white/5 hover:bg-white/10 flex items-center justify-center transition-colors">
                                        <i class="ph-bold ph-plus text-xs"></i>
                                    </button>
                                </div>
                            </div>

                            <!-- Timer Controls -->
                            <div class="bg-white/5 p-3 rounded-xl border border-white/5 space-y-3">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm text-gray-300">Timer (min)</span>
                                    <input type="number" v-model="timerDuration" min="1" max="60"
                                        class="glass-input w-16 rounded-lg px-2 py-1 text-center font-mono text-sm"
                                        :disabled="isTimerRunning">
                                </div>
                                <div class="flex items-center justify-between gap-3">
                                    <div class="font-mono text-2xl font-bold text-white tracking-wider flex-1 text-center bg-black/20 rounded-lg py-1"
                                        :class="{'text-red-400 animate-pulse': timeRemaining === 0 && isTimerRunning === false && timerStarted}">
                                        {{ formatTime(timeRemaining) }}
                                    </div>
                                    <button @click="toggleTimer"
                                        class="w-10 h-10 rounded-lg flex items-center justify-center transition-colors"
                                        :class="isTimerRunning ? 'bg-yellow-500/20 text-yellow-400 hover:bg-yellow-500/30' : 'bg-green-500/20 text-green-400 hover:bg-green-500/30'">
                                        <i class="ph-bold" :class="isTimerRunning ? 'ph-pause' : 'ph-play'"></i>
                                    </button>
                                    <button @click="resetTimer"
                                        class="w-10 h-10 rounded-lg bg-white/5 hover:bg-white/10 text-gray-400 flex items-center justify-center transition-colors">
                                        <i class="ph-bold ph-arrow-counter-clockwise"></i>
                                    </button>
                                </div>
                            </div>

                            <button @click="startSession" :disabled="waitingQueue.length === 0"
                                class="w-full py-3 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white font-medium shadow-lg shadow-blue-600/20 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none transition-all active:scale-[0.98] flex items-center justify-center gap-2 group">
                                <i class="ph-bold ph-play group-hover:fill-current"></i>
                                Start Next Session
                            </button>

                            <button @click="pickRandomSession" :disabled="waitingQueue.length === 0"
                                class="w-full py-3 rounded-xl bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-all active:scale-[0.98] flex items-center justify-center gap-2">
                                <i class="ph-bold ph-shuffle"></i>
                                Pick Random
                            </button>
                        </div>
                    </div>

                    <!-- YouTube Settings Card -->
                    <div class="glass-panel rounded-2xl p-5 animate-slide-up" style="animation-delay: 0.3s;">
                        <h2
                            class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-4 flex items-center gap-2">
                            <i class="ph ph-youtube-logo text-lg text-red-500"></i> YouTube Live
                        </h2>

                        <div class="space-y-3">
                            <div>
                                <label class="text-xs text-gray-500 mb-1 block">API Key</label>
                                <input type="password" v-model="apiKey"
                                    class="glass-input w-full rounded-lg px-3 py-2 text-xs font-mono"
                                    placeholder="AIzaSy...">
                            </div>
                            <div>
                                <label class="text-xs text-gray-500 mb-1 block">Video ID</label>
                                <input type="text" v-model="videoId"
                                    class="glass-input w-full rounded-lg px-3 py-2 text-xs font-mono"
                                    placeholder="Video ID">
                            </div>
                            <div>
                                <label class="text-xs text-gray-500 mb-1 block">Join Keyword</label>
                                <input type="text" v-model="joinKeyword"
                                    class="glass-input w-full rounded-lg px-3 py-2 text-xs font-mono"
                                    placeholder="参加希望">
                            </div>
                            <div>
                                <label class="text-xs text-gray-500 mb-1 block">Leave Keyword</label>
                                <input type="text" v-model="leaveKeyword"
                                    class="glass-input w-full rounded-lg px-3 py-2 text-xs font-mono"
                                    placeholder="参加辞退">
                            </div>

                            <button @click="connectYouTube"
                                :class="isConnected ? 'bg-green-600/20 text-green-400 border-green-500/30' : 'bg-red-600 hover:bg-red-500 text-white shadow-red-600/20'"
                                class="w-full py-2.5 mt-2 rounded-lg border border-transparent font-medium text-sm transition-all shadow-lg flex items-center justify-center gap-2">
                                <i class="ph-bold" :class="isConnected ? 'ph-check' : 'ph-plug'"></i>
                                {{ isConnected ? 'Connected' : 'Connect Stream' }}
                            </button>

                            <div v-if="connectionError"
                                class="p-3 rounded-lg bg-red-500/10 border border-red-500/20 text-red-400 text-xs mt-2">
                                <i class="ph-bold ph-warning-circle mr-1"></i> {{ connectionError }}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Center Column: Waiting Queue (5 cols) -->
                <div class="lg:col-span-5 flex flex-col h-full overflow-hidden glass-panel rounded-2xl animate-slide-up"
                    style="animation-delay: 0.15s;">
                    <div class="p-5 border-b border-white/5 flex items-center justify-between bg-white/[0.02]">
                        <div class="flex items-center gap-3">
                            <div class="p-2 rounded-lg bg-orange-500/10 text-orange-400">
                                <i class="ph-bold ph-hourglass-high text-xl"></i>
                            </div>
                            <div>
                                <h2 class="font-semibold text-white">Waiting Queue</h2>
                                <p class="text-xs text-gray-500">Players waiting to join</p>
                            </div>
                        </div>
                        <div
                            class="px-3 py-1 rounded-full bg-white/5 border border-white/10 text-sm font-mono text-gray-300">
                            {{ waitingQueue.length }}
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto p-4 space-y-2 relative">
                        <div v-if="waitingQueue.length === 0"
                            class="absolute inset-0 flex flex-col items-center justify-center text-gray-600">
                            <i class="ph-duotone ph-users-three text-6xl mb-4 opacity-20"></i>
                            <p class="text-sm">Queue is empty</p>
                        </div>

                        <transition-group name="list">
                            <div v-for="(user, index) in sortedWaitingQueue" :key="user.id"
                                class="group flex items-center justify-between p-3 rounded-xl bg-white/[0.03] hover:bg-white/[0.06] border border-white/5 hover:border-white/10 transition-all">
                                <div class="flex items-center gap-4">
                                    <div class="relative">
                                        <div
                                            class="w-10 h-10 rounded-full bg-gradient-to-br from-gray-700 to-gray-800 flex items-center justify-center text-sm font-bold text-gray-300 border border-white/10">
                                            {{ user.name.charAt(0).toUpperCase() }}
                                        </div>
                                        <div v-if="user.playCount > 0"
                                            class="absolute -top-1 -right-1 w-5 h-5 rounded-full bg-orange-500/20 border border-orange-500/50 text-orange-400 text-[10px] font-bold flex items-center justify-center">
                                            {{ user.playCount }}
                                        </div>
                                    </div>
                                    <div>
                                        <div class="font-medium text-gray-200">{{ user.name }}</div>
                                        <div class="text-xs text-gray-500 flex items-center gap-1">
                                            <i class="ph ph-clock"></i> {{ getRelativeTime(user.joinedAt) }}
                                        </div>
                                    </div>
                                </div>

                                <div
                                    class="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button @click="moveToSession(user)"
                                        class="p-2 rounded-lg bg-blue-500/10 text-blue-400 hover:bg-blue-500 hover:text-white transition-colors"
                                        title="Move to Session">
                                        <i class="ph-bold ph-play"></i>
                                    </button>
                                    <button @click="removeUser(user.id)"
                                        class="p-2 rounded-lg bg-red-500/10 text-red-400 hover:bg-red-500 hover:text-white transition-colors"
                                        title="Remove">
                                        <i class="ph-bold ph-x"></i>
                                    </button>
                                </div>
                            </div>
                        </transition-group>
                    </div>
                </div>

                <!-- Right Column: Active & History (4 cols) -->
                <div class="lg:col-span-4 flex flex-col gap-6 h-full overflow-hidden">

                    <!-- Current Session -->
                    <div class="flex-1 flex flex-col glass-panel rounded-2xl animate-slide-up overflow-hidden"
                        style="animation-delay: 0.25s;">
                        <div class="p-5 border-b border-white/5 flex items-center justify-between bg-blue-500/[0.02]">
                            <div class="flex items-center gap-3">
                                <div class="p-2 rounded-lg bg-blue-500/10 text-blue-400">
                                    <i class="ph-bold ph-game-controller text-xl"></i>
                                </div>
                                <div>
                                    <h2 class="font-semibold text-white">Current Session</h2>
                                    <p class="text-xs text-gray-500">Playing now</p>
                                </div>
                            </div>
                            <div class="flex items-center gap-2">
                                <button @click="cancelSession" :disabled="currentSession.length === 0"
                                    class="text-xs px-3 py-1.5 rounded-lg bg-red-500/10 text-red-400 border border-red-500/20 hover:bg-red-500/20 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                                    Cancel
                                </button>
                                <button @click="endSession" :disabled="currentSession.length === 0"
                                    class="text-xs px-3 py-1.5 rounded-lg bg-green-500/10 text-green-400 border border-green-500/20 hover:bg-green-500/20 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                                    End Session
                                </button>
                            </div>
                        </div>

                        <div class="flex-1 overflow-y-auto p-4 space-y-2 relative min-h-[200px]">
                            <div v-if="currentSession.length === 0"
                                class="absolute inset-0 flex flex-col items-center justify-center text-gray-600">
                                <i class="ph-duotone ph-game-controller text-5xl mb-3 opacity-20"></i>
                                <p class="text-sm">No active session</p>
                            </div>

                            <transition-group name="list">
                                <div v-for="user in currentSession" :key="user.id"
                                    class="flex items-center justify-between p-3 rounded-xl bg-blue-500/[0.05] border border-blue-500/20 relative overflow-hidden group">
                                    <div
                                        class="absolute inset-0 bg-gradient-to-r from-blue-500/5 to-transparent pointer-events-none">
                                    </div>

                                    <div class="flex items-center gap-3 relative z-10">
                                        <div
                                            class="w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-sm font-bold text-white shadow-lg shadow-blue-600/30">
                                            {{ user.name.charAt(0).toUpperCase() }}
                                        </div>
                                        <div>
                                            <div class="font-medium text-white">{{ user.name }}</div>
                                            <div class="text-xs text-blue-300/70">Playing</div>
                                        </div>
                                    </div>

                                    <div class="flex items-center gap-1 relative z-10">
                                        <button @click="finishUser(user)"
                                            class="p-1.5 rounded-lg text-green-400 hover:bg-green-500/20 transition-colors"
                                            title="Finish">
                                            <i class="ph-bold ph-check"></i>
                                        </button>
                                        <button @click="returnToQueue(user)"
                                            class="p-1.5 rounded-lg text-gray-400 hover:bg-white/10 transition-colors"
                                            title="Return to Queue">
                                            <i class="ph-bold ph-arrow-u-up-left"></i>
                                        </button>
                                    </div>
                                </div>
                            </transition-group>
                        </div>
                    </div>

                    <!-- History -->
                    <div class="h-1/3 flex flex-col glass-panel rounded-2xl animate-slide-up overflow-hidden"
                        style="animation-delay: 0.35s;">
                        <div
                            class="px-5 py-3 border-b border-white/5 bg-white/[0.02] flex items-center justify-between">
                            <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">History</h3>
                            <span class="text-xs text-gray-600">{{ finishedList.length }} finished</span>
                        </div>
                        <div class="flex-1 overflow-y-auto p-3 space-y-1">
                            <div v-if="finishedList.length === 0" class="text-center py-8 text-gray-600 text-xs italic">
                                No history yet
                            </div>
                            <div v-for="user in finishedList" :key="user.id"
                                class="flex items-center justify-between p-2 rounded-lg hover:bg-white/[0.03] transition-colors group">
                                <div
                                    class="flex items-center gap-3 opacity-60 group-hover:opacity-100 transition-opacity">
                                    <span class="text-sm text-gray-300">{{ user.name }}</span>
                                    <span class="text-[10px] px-1.5 py-0.5 rounded bg-white/10 text-gray-400">x{{
                                        user.playCount }}</span>
                                </div>
                                <button @click="returnToQueue(user)"
                                    class="text-gray-600 hover:text-blue-400 opacity-0 group-hover:opacity-100 transition-all">
                                    <i class="ph-bold ph-arrow-u-up-left"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </main>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                // State
                const waitingQueue = ref([]);
                const currentSession = ref([]);
                const finishedList = ref([]);
                const newUserName = ref('');
                const sessionSize = ref(4);

                // Timer State
                const timerDuration = ref(10); // minutes
                const timeRemaining = ref(600); // seconds
                const isTimerRunning = ref(false);
                const timerStarted = ref(false); // To track if timer has ever started for alert styling
                let timerInterval = null;

                // Settings
                const apiKey = ref('');
                const videoId = ref('');
                const joinKeyword = ref('参加希望');
                const leaveKeyword = ref('参加辞退');
                const isConnected = ref(false);
                const connectionError = ref('');
                let pollingInterval = null;
                let nextPageToken = null;

                // Helper
                const compareUsers = (a, b) => {
                    const countA = a.playCount || 0;
                    const countB = b.playCount || 0;
                    if (countA !== countB) return countA - countB;
                    return new Date(a.joinedAt) - new Date(b.joinedAt);
                };

                // Computed
                const sortedWaitingQueue = computed(() => {
                    return [...waitingQueue.value].sort(compareUsers);
                });

                // Load from LocalStorage
                onMounted(() => {
                    const savedData = localStorage.getItem('pm_data');
                    if (savedData) {
                        try {
                            const parsed = JSON.parse(savedData);
                            waitingQueue.value = parsed.waitingQueue || [];
                            // Handle legacy structure
                            if (parsed.currentPlayer) {
                                currentSession.value = [parsed.currentPlayer];
                            } else {
                                currentSession.value = parsed.currentSession || [];
                            }
                            finishedList.value = parsed.finishedList || [];
                            apiKey.value = parsed.apiKey || '';
                            videoId.value = parsed.videoId || '';
                            joinKeyword.value = parsed.joinKeyword || '参加希望';
                            leaveKeyword.value = parsed.leaveKeyword || '参加辞退';
                            sessionSize.value = (typeof parsed.sessionSize === 'number') ? parsed.sessionSize : 4;
                            timerDuration.value = (typeof parsed.timerDuration === 'number') ? parsed.timerDuration : 10;
                            timeRemaining.value = timerDuration.value * 60;
                        } catch (e) {
                            console.error("Failed to load data", e);
                        }
                    }
                });

                // Save to LocalStorage
                watch([waitingQueue, currentSession, finishedList, apiKey, videoId, joinKeyword, leaveKeyword, sessionSize, timerDuration], () => {
                    localStorage.setItem('pm_data', JSON.stringify({
                        waitingQueue: waitingQueue.value,
                        currentSession: currentSession.value,
                        finishedList: finishedList.value,
                        apiKey: apiKey.value,
                        videoId: videoId.value,
                        joinKeyword: joinKeyword.value,
                        leaveKeyword: leaveKeyword.value,
                        sessionSize: sessionSize.value,
                        timerDuration: timerDuration.value
                    }));
                }, { deep: true });

                // Timer Logic
                const formatTime = (seconds) => {
                    const m = Math.floor(seconds / 60);
                    const s = seconds % 60;
                    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                };

                const startTimer = () => {
                    if (isTimerRunning.value) return;
                    isTimerRunning.value = true;
                    timerStarted.value = true;
                    timerInterval = setInterval(() => {
                        if (timeRemaining.value > 0) {
                            timeRemaining.value--;
                        } else {
                            stopTimer();
                            playAlert();
                        }
                    }, 1000);
                };

                const stopTimer = () => {
                    isTimerRunning.value = false;
                    if (timerInterval) clearInterval(timerInterval);
                };

                const resetTimer = () => {
                    stopTimer();
                    timeRemaining.value = timerDuration.value * 60;
                    timerStarted.value = false;
                };

                const toggleTimer = () => {
                    if (isTimerRunning.value) {
                        stopTimer();
                    } else {
                        startTimer();
                    }
                };

                const playAlert = () => {
                    // Simple beep using AudioContext or just visual for now
                    // Visual is handled by class binding
                    // Optional: Add sound
                    try {
                        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioCtx.createOscillator();
                        const gainNode = audioCtx.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(audioCtx.destination);
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime + 0.5);
                        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 1);
                        oscillator.start();
                        oscillator.stop(audioCtx.currentTime + 1);
                    } catch (e) {
                        console.error("Audio play failed", e);
                    }
                    alert("Time's Up!");
                };

                // Watch timerDuration to update timeRemaining if not running
                watch(timerDuration, (newVal) => {
                    if (!isTimerRunning.value && !timerStarted.value) {
                        timeRemaining.value = newVal * 60;
                    }
                });

                // Actions
                const addManualUser = () => {
                    if (!newUserName.value.trim()) return;
                    addUserCorrect(newUserName.value.trim());
                    newUserName.value = '';
                };

                const addUserCorrect = (name) => {
                    // Find existing playCount
                    let playCount = 0;

                    // Check Waiting Queue
                    const queueUser = waitingQueue.value.find(u => u.name === name);
                    if (queueUser) playCount = queueUser.playCount || 0;

                    // Check Current Session
                    const sessionUser = currentSession.value.find(u => u.name === name);
                    if (sessionUser) playCount = sessionUser.playCount || 0;

                    // Check Finished List
                    const finishedUser = finishedList.value.find(u => u.name === name);
                    if (finishedUser) playCount = finishedUser.playCount || 0;

                    // Remove from waiting queue if present (to re-add at bottom)
                    const existingInQueueIndex = waitingQueue.value.findIndex(u => u.name === name);
                    if (existingInQueueIndex !== -1) {
                        waitingQueue.value.splice(existingInQueueIndex, 1);
                    }

                    // Only add if not currently playing
                    const isPlaying = currentSession.value.some(u => u.name === name);
                    if (!isPlaying) {
                        waitingQueue.value.push({
                            id: Date.now() + Math.random(),
                            name: name,
                            status: 'waiting',
                            joinedAt: new Date().toISOString(),
                            playCount: playCount
                        });
                    }
                };

                const removeUser = (id) => {
                    waitingQueue.value = waitingQueue.value.filter(u => u.id !== id);
                };

                const removeUserByName = (name) => {
                    // Remove from waiting queue only (not from current session)
                    const beforeLength = waitingQueue.value.length;
                    waitingQueue.value = waitingQueue.value.filter(u => u.name !== name);
                    const afterLength = waitingQueue.value.length;
                    return beforeLength !== afterLength; // Returns true if user was removed
                };

                // Session Logic
                const startSession = () => {
                    if (waitingQueue.value.length === 0) return;

                    // End current session first
                    endSession();

                    let size = parseInt(sessionSize.value);
                    if (isNaN(size) || size < 1) size = 1;

                    // Sort Queue before picking
                    waitingQueue.value.sort(compareUsers);

                    const count = Math.min(size, waitingQueue.value.length);
                    const nextPlayers = waitingQueue.value.splice(0, count);

                    nextPlayers.forEach(p => {
                        currentSession.value.push({ ...p, status: 'playing' });
                    });

                    // Start Timer
                    resetTimer();
                    startTimer();
                };

                const pickRandomSession = () => {
                    if (waitingQueue.value.length === 0) return;

                    let size = parseInt(sessionSize.value);
                    if (isNaN(size) || size < 1) size = 1;

                    const count = Math.min(size, waitingQueue.value.length);
                    for (let i = 0; i < count; i++) {
                        if (waitingQueue.value.length === 0) break;
                        const index = Math.floor(Math.random() * waitingQueue.value.length);
                        const [picked] = waitingQueue.value.splice(index, 1);
                        currentSession.value.push({ ...picked, status: 'playing' });
                    }

                    // Start Timer
                    resetTimer();
                    startTimer();
                };

                const endSession = () => {
                    const players = [...currentSession.value];
                    players.forEach(p => {
                        const newCount = (p.playCount || 0) + 1;
                        finishedList.value.unshift({ ...p, status: 'finished', playCount: newCount });
                    });
                    currentSession.value = [];
                    stopTimer();
                };

                const cancelSession = () => {
                    if (currentSession.value.length === 0) return;
                    if (!confirm('Are you sure you want to cancel the current session? All players will return to the queue.')) return;

                    const players = [...currentSession.value];
                    players.forEach(p => {
                        waitingQueue.value.push({ ...p, status: 'waiting' });
                    });
                    currentSession.value = [];
                    resetTimer();
                };

                const moveToSession = (user) => {
                    removeUser(user.id);
                    currentSession.value.push({ ...user, status: 'playing' });
                };

                const finishUser = (user) => {
                    currentSession.value = currentSession.value.filter(u => u.id !== user.id);
                    const newCount = (user.playCount || 0) + 1;
                    finishedList.value.unshift({ ...user, status: 'finished', playCount: newCount });
                };

                const returnToQueue = (user) => {
                    if (currentSession.value.find(u => u.id === user.id)) {
                        currentSession.value = currentSession.value.filter(u => u.id !== user.id);
                    } else {
                        finishedList.value = finishedList.value.filter(u => u.id !== user.id);
                    }
                    waitingQueue.value.push({ ...user, status: 'waiting' });
                };

                const resetAll = () => {
                    if (!confirm('Are you sure you want to reset all data?')) return;
                    waitingQueue.value = [];
                    currentSession.value = [];
                    finishedList.value = [];
                    sessionSize.value = 4;
                };

                // YouTube Integration
                const connectYouTube = async () => {
                    if (!apiKey.value || !videoId.value) {
                        connectionError.value = 'API Key and Video ID are required.';
                        return;
                    }

                    connectionError.value = '';
                    try {
                        const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${videoId.value}&key=${apiKey.value}`);
                        const data = await response.json();

                        if (data.error) {
                            throw new Error(data.error.message);
                        }

                        if (data.items.length === 0) {
                            throw new Error('Video not found.');
                        }

                        const liveChatId = data.items[0].liveStreamingDetails?.activeLiveChatId;
                        if (!liveChatId) {
                            throw new Error('Live chat not active or not found.');
                        }

                        isConnected.value = true;
                        startPolling(liveChatId);

                    } catch (e) {
                        connectionError.value = e.message;
                        isConnected.value = false;
                    }
                };

                const startPolling = (liveChatId) => {
                    if (pollingInterval) clearInterval(pollingInterval);

                    pollingInterval = setInterval(async () => {
                        try {
                            let url = `https://www.googleapis.com/youtube/v3/liveChat/messages?liveChatId=${liveChatId}&part=snippet,authorDetails&key=${apiKey.value}`;
                            if (nextPageToken) {
                                url += `&pageToken=${nextPageToken}`;
                            }

                            const res = await fetch(url);
                            const data = await res.json();

                            if (data.nextPageToken) {
                                nextPageToken = data.nextPageToken;
                            }

                            if (data.items) {
                                data.items.forEach(item => {
                                    const message = item.snippet.displayMessage;
                                    const authorName = item.authorDetails.displayName;
                                    
                                    // Check for leave keyword first
                                    if (message.includes(leaveKeyword.value)) {
                                        removeUserByName(authorName);
                                    }
                                    // Then check for join keyword
                                    else if (message.includes(joinKeyword.value)) {
                                        addUserCorrect(authorName);
                                    }
                                });
                            }
                        } catch (e) {
                            console.error('Polling error', e);
                        }
                    }, 5000);
                };

                // Relative time helper
                const getRelativeTime = (timestamp) => {
                    if (!timestamp) return '';
                    const now = new Date();
                    const past = new Date(timestamp);
                    const diffMs = now - past;
                    const diffSec = Math.floor(diffMs / 1000);
                    const diffMin = Math.floor(diffSec / 60);
                    const diffHour = Math.floor(diffMin / 60);
                    const diffDay = Math.floor(diffHour / 24);

                    if (diffSec < 60) return `${diffSec}s ago`;
                    if (diffMin < 60) return `${diffMin}m ago`;
                    if (diffHour < 24) return `${diffHour}h ago`;
                    return `${diffDay}d ago`;
                };

                return {
                    waitingQueue,
                    sortedWaitingQueue,
                    currentSession,
                    finishedList,
                    newUserName,
                    sessionSize,
                    addManualUser,
                    removeUser,
                    startSession,
                    endSession,
                    pickRandomSession,
                    moveToSession,
                    finishUser,
                    returnToQueue,
                    resetAll,
                    apiKey,
                    videoId,
                    joinKeyword,
                    leaveKeyword,
                    connectYouTube,
                    isConnected,
                    connectionError,
                    addUser: addUserCorrect,
                    getRelativeTime,
                    timerDuration,
                    timeRemaining,
                    isTimerRunning,
                    formatTime,
                    toggleTimer,
                    resetTimer,
                    timerStarted,
                    cancelSession
                };
            }
        }).mount('#app');
    </script>
</body>

</html>